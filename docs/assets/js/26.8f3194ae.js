(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{397:function(e,a,s){"use strict";s.r(a);var o=s(29),r=Object(o.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("Desde as primeiras versões, Java dispõe das estruturas de arrays e as classes "),s("code",[e._v("Vector")]),e._v(" e "),s("code",[e._v("Hashtable")]),e._v(". No entanto, além da dificuldade em implementar estruturas de dados utilizando arrays, os desenvolvedores sentiam falta de classes que implementassem estruturas como listas ligadas e tabelas de espalhamento (hash). Para atender a essas necessidades, a partir de Java 1.2, foi criado um conjunto de interfaces e classes denominado Collections Framework, que faz parte do pacote "),s("code",[e._v("java.util")]),e._v(".")]),e._v(" "),s("h1",{attrs:{id:"o-que-e-collections-framework"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#o-que-e-collections-framework"}},[e._v("#")]),e._v(" O que é Collections Framework?")]),e._v(" "),s("p",[e._v("Collections Framework é um conjunto bem definido de interfaces e classes para representar e tratar grupos de dados como uma única unidade, que pode ser chamada coleção, ou collection. A Collections Framework contém os seguintes elementos:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Interfaces")]),e._v(": tipos abstratos que representam as coleções. Permitem que coleções sejam manipuladas tendo como base o conceito “Programar para interfaces e não para implementações”, desde que o acesso aos objetos se restrinja apenas ao uso de métodos definidos nas interfaces;")]),e._v(" "),s("li",[s("strong",[e._v("Implementações")]),e._v(": são as implementações concretas das interfaces;")]),e._v(" "),s("li",[s("strong",[e._v("Algoritmos")]),e._v(": são os métodos que realizam as operações sobre os objetos das coleções, tais como busca e ordenação.")])]),e._v(" "),s("p",[e._v("A Figura 1 mostra a árvore da hierarquia de interfaces e classes da Java Collections Framework que são derivadas da interface "),s("code",[e._v("Collection")]),e._v(". O diagrama usa a notação da UML, onde as linhas cheias representam "),s("code",[e._v("extends")]),e._v(" e as linhas pontilhadas representam "),s("code",[e._v("implements")]),e._v(".")]),e._v(" "),s("figure",[s("img",{attrs:{src:"https://arquivo.devmedia.com.br/REVISTAS/easyjava/imagens/1/4/image001.jpg"}}),e._v(" "),s("figcaption",[e._v("A hierarquia de interfaces e classes.")])]),e._v(" "),s("p",[e._v("A hierarquia da Collections Framework tem uma segunda árvore. São as classes e interfaces relacionadas a mapas, que não são derivadas de "),s("code",[e._v("Collection")]),e._v(", como mostra a Figura 2. Essas interfaces, mesmo não sendo consideradas coleções, podem ser manipuladas como tal.")]),e._v(" "),s("figure",[s("img",{attrs:{src:"https://arquivo.devmedia.com.br/REVISTAS/easyjava/imagens/1/4/image002.jpg"}}),e._v(" "),s("figcaption",[e._v("Hierarquia de mapas.")])]),e._v(" "),s("h2",{attrs:{id:"interfaces"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interfaces"}},[e._v("#")]),e._v(" Interfaces")]),e._v(" "),s("p",[e._v("Neste momento vamos apresentar uma breve descrição de cada uma das interfaces da hierarquia:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("Collection")]),e._v(" – está no topo da hierarquia. Não existe implementação direta dessa interface, mas ela define as operações básicas para as coleções, como adicionar, remover, esvaziar, etc.;")]),e._v(" "),s("li",[s("code",[e._v("Set")]),e._v(" – interface que define uma coleção que não permite elementos duplicados. A interface "),s("code",[e._v("SortedSet")]),e._v(", que estende "),s("code",[e._v("Set")]),e._v(", possibilita a classificação natural dos elementos, tal como a ordem alfabética;")]),e._v(" "),s("li",[s("code",[e._v("List")]),e._v(" – define uma coleção ordenada, podendo conter elementos duplicados. Em geral, o usuário tem controle total sobre a posição onde cada elemento é inserido e pode recuperá-los através de seus índices. Prefira esta interface quando precisar de acesso aleatório, através do índice do elemento;")]),e._v(" "),s("li",[s("code",[e._v("Queue")]),e._v(" – um tipo de coleção para manter uma lista de prioridades, onde a ordem dos seus elementos, definida pela implementação de Comparable ou Comparator, determina essa prioridade. Com a interface fila pode-se criar filas e pilhas;")]),e._v(" "),s("li",[s("code",[e._v("Map")]),e._v(" – mapeia chaves para valores. Cada elemento tem na verdade dois objetos: uma chave e um valor. Valores podem ser duplicados, mas chaves não. "),s("code",[e._v("SortedMap")]),e._v(" é uma interface que estende "),s("code",[e._v("Map")]),e._v(", e permite classificação ascendente das chaves. Uma aplicação dessa interface é a classe Properties, que é usada para persistir propriedades/configurações de um sistema, por exemplo.")])]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("Observe que usamos acima os termos "),s("em",[e._v("ordenação")]),e._v(" e "),s("em",[e._v("classificação")]),e._v(". Dizemos que uma estrutura está ordenada se ela pode ser percorrida (iterada) em uma certa ordem, tal como os itens de um "),s("code",[e._v("ArrayList")]),e._v(" podem ser percorridos através de seus índices. Por sua vez, a classificação diz respeito à ordenação na essência dos dados, tal como a classificação em ordem alfabética de "),s("em",[e._v("Strings")]),e._v(" ou ordem numérica das classes "),s("em",[e._v("wrapper")]),e._v(", como "),s("code",[e._v("Integer")]),e._v(" e "),s("code",[e._v("Double")]),e._v(", por exemplo. Podemos afirmar que uma estrutura classificada é uma estrutura ordenada, mas o inverso não é verdadeiro.")])]),e._v(" "),s("p",[e._v("A API oferece também interfaces que permitem percorrer uma coleção derivada de Collection. Neste artigo falaremos de:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("Iterator")]),e._v(" – possibilita percorrer uma coleção e remover seus elementos;")]),e._v(" "),s("li",[s("code",[e._v("ListIterator")]),e._v(" – estende "),s("code",[e._v("Iterator")]),e._v(" e suporta acesso bidirecional em uma lista, modificando e/ou removendo elementos.")])]),e._v(" "),s("h2",{attrs:{id:"implementacoes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#implementacoes"}},[e._v("#")]),e._v(" Implementações")]),e._v(" "),s("p",[e._v("As interfaces apresentadas anteriormente possuem diversas implementações que são utilizadas para armazenar as coleções. Na Tabela 1 estão resumidas as implementações mais comuns.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Interfaces")]),e._v(" "),s("th",[e._v("Tabela de Espalhamento")]),e._v(" "),s("th",[e._v("Array Redimensionável")]),e._v(" "),s("th",[e._v("Árvore")]),e._v(" "),s("th",[e._v("Lista Ligada")]),e._v(" "),s("th",[e._v("Tabela de Espalhamento + Lista Ligada")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Set")]),e._v(" "),s("td",[e._v("HashSet")]),e._v(" "),s("td"),e._v(" "),s("td",[e._v("TreeSet")]),e._v(" "),s("td"),e._v(" "),s("td",[e._v("LinkedHashSet")])]),e._v(" "),s("tr",[s("td",[e._v("List")]),e._v(" "),s("td"),e._v(" "),s("td",[e._v("ArrayList")]),e._v(" "),s("td"),e._v(" "),s("td",[e._v("LinkedList")]),e._v(" "),s("td")]),e._v(" "),s("tr",[s("td",[e._v("Queue")]),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td")]),e._v(" "),s("tr",[s("td",[e._v("Map")]),e._v(" "),s("td",[e._v("HashMap")]),e._v(" "),s("td"),e._v(" "),s("td",[e._v("TreeMap")]),e._v(" "),s("td"),e._v(" "),s("td",[e._v("LinkedHashMap")])])])]),e._v(" "),s("p",[e._v(": Implementações de uso geral")])])}),[],!1,null,null,null);a.default=r.exports}}]);